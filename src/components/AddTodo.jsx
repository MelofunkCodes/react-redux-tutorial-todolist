import React from 'react';
import { connect } from 'react-redux';

let nextToDoId = 0;

/*
 Changed from const to let. This lets us reassign AddTodo, so the consuming component doesn't need
 to specify the dispatch prop. We don't have to specify dispatch as a prop because it will be
 injected by the component generated by the connect call.
  */
let AddTodo = ({ dispatch }) => {
  let input; // make it a local variable

  return (
    <div>
      <input ref={(node) => {
        /*
         using the ref attribute to link whatever the user types in the input so that we can
         then access it with this.input.value
          */
        input = node;
      }}
      />
      <button onClick={() => {
        dispatch({
          type: 'ADD_TODO',
          text: input.value,
          id: nextToDoId += 1,
        });
        input.value = ''; // clears the input field after button is clicked
      }}
      >
        Add Todo
      </button>
    </div>
  );
};

/*
Below is the same thing as:
AddTodo = connect(
  state => {
    return {};
  },
  dispatch => {
    return { dispatch };
  }
)(AddTodo);

-- or --
(since it is wasteful to subscribe to the store if you aren't going to calculate props..., and it's
common pattern to inject dispatch function):
AddTodo = connect(null, null)(AddTodo);


In this case, the connect call that doesn't take any arguments will generate a container component
that does not subscribe to the store, however it will pass dispatch to the component that it wraps.
In this case, it wraps the AddTodo component. The second connect call, returns the generated
container component, and assigns it to AddTodo.
 */
AddTodo = connect()(AddTodo);

export default AddTodo;
